<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Hallucination Controls</title>
  <link rel="stylesheet" href="/assets/frame-theme.css?v=ballpoint2">
  <style>
    :root {
      --bg: transparent;
      --panel: #0f1d2a;
      --accent: #e63946;
      --text: #1a0000;
      --muted: #8b0000;
      font-family: var(--rv-font);
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      background: url('/assets/thenotebookpiece2.png?v=2') center/cover no-repeat scroll;
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
      color: var(--text);
      min-height: 100vh;
      padding: 2rem;
      font-family: var(--rv-font);
    }

    #controls-container {
      max-width: 800px;
      margin: 0 auto;
      background: none !important;
      border: none !important;
      box-shadow: none !important;
      position: relative;
    }

    h1 {
      color: var(--accent);
      margin-bottom: 0.5rem;
      filter: url(#ballpoint-ink) contrast(1.4) brightness(0.92);
      text-shadow: 
        2px 2px 4px rgba(0, 0, 0, 0.7),
        -1px 1px 2px rgba(0, 0, 0, 0.5),
        0 0 8px rgba(15, 242, 195, 0.3);
      letter-spacing: 0.08em;
      font-weight: 700;
      transform: skewX(-3deg);
    }

    .subtitle {
      color: var(--muted);
      margin-bottom: 2rem;
      filter: url(#ballpoint-ink) contrast(1.3) brightness(0.94);
      text-shadow: 
        1.5px 1.5px 3px rgba(0, 0, 0, 0.6),
        -0.8px 0.8px 1.5px rgba(0, 0, 0, 0.4);
      letter-spacing: 0.06em;
      font-weight: 500;
      transform: skewX(-2deg);
    }

    section {
      background: none !important;
      border: none !important;
      padding: 0 !important;
      margin-bottom: 2rem;
      border-radius: 0 !important;
      background-image: none !important;
    }

    h3 {
      margin-top: 0;
      color: var(--accent);
      filter: url(#ballpoint-ink) contrast(1.35) brightness(0.9);
      text-shadow: 
        1.5px 1.5px 3px rgba(0, 0, 0, 0.65),
        -0.8px 0.8px 1.5px rgba(0, 0, 0, 0.45);
      letter-spacing: 0.07em;
      font-weight: 650;
      transform: skewX(-2.5deg);
    }

    button {
      background-color: var(--accent);
      background-image: none !important;
      color: var(--bg);
      border: none;
      padding: 0.75rem 1.5rem;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
      font-size: 1rem;
      transition: opacity 0.2s;
      filter: url(#ballpoint-ink) contrast(1.3) brightness(0.95);
      text-shadow: 
        1px 1px 2px rgba(0, 0, 0, 0.5),
        -0.5px 0.5px 1px rgba(0, 0, 0, 0.3);
    }

    button:hover {
      opacity: 0.8;
    }

    input[type="range"] {
      width: 100%;
      margin: 0.5rem 0;
      background-image: none !important;
    }

    input[type="checkbox"] {
      margin-right: 0.5rem;
      background-image: none !important;
    }

    input[type="number"],
    input[type="text"],
    input[type="file"] {
      background-image: none !important;
    }

    label {
      display: flex;
      align-items: center;
      margin: 0.5rem 0;
      cursor: pointer;
      filter: url(#ballpoint-ink) contrast(1.25) brightness(0.96);
      text-shadow: 
        1px 1px 2px rgba(0, 0, 0, 0.4),
        -0.5px 0.5px 1px rgba(0, 0, 0, 0.25);
    }

    .slider-group {
      margin: 1rem 0;
    }

    .slider-label {
      display: flex;
      justify-content: space-between;
      margin-bottom: 0.25rem;
      font-size: 0.9rem;
      filter: url(#ballpoint-ink) contrast(1.25) brightness(0.96);
      text-shadow: 
        1px 1px 2px rgba(0, 0, 0, 0.4),
        -0.5px 0.5px 1px rgba(0, 0, 0, 0.25);
    }

    .pack-card {
      border: none !important;
      border-radius: 0 !important;
      padding: 0.5rem 0 !important;
      margin-bottom: 0.75rem;
      background: none !important;
      background-image: none !important;
    }

    .pack-card:first-child {
      transform: rotate(30deg) !important;
      transform-origin: left top !important;
      margin-top: 3rem !important;
      margin-bottom: 8rem !important;
      margin-left: 2rem !important;
      position: relative !important;
    }

    details {
      margin-top: 0.75rem;
      background: none !important;
      border: none !important;
    }

    summary {
      cursor: pointer;
      font-weight: 600;
      margin-bottom: 0.5rem;
      background: none !important;
      border: none !important;
      list-style: none;
      filter: url(#ballpoint-ink) contrast(1.3) brightness(0.94);
      text-shadow: 
        1.5px 1.5px 3px rgba(0, 0, 0, 0.5),
        -0.8px 0.8px 1.5px rgba(0, 0, 0, 0.35);
    }

    summary::-webkit-details-marker {
      display: none;
    }

    .mood-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 0.5rem;
      margin-top: 0.5rem;
      background: none !important;
      border: none !important;
    }

    * {
      background-image: none !important;
    }
  </style>
</head>
<body style="margin: 0; background-image: url('/assets/thenotebookpiece2.png'); background-attachment: scroll; background-size: cover; background-position: center; background-repeat: no-repeat; color: #1a0000; padding: 2rem; min-height: 100vh; font-family: var(--rv-font);">
  <!-- Import ballpoint ink filter for notebook aesthetic on headings -->
  <svg width="0" height="0" style="position: absolute; pointer-events: none;" aria-hidden="true">
    <defs>
      <filter id="ballpoint-ink" x="-5%" y="-5%" width="110%" height="110%" color-interpolation-filters="sRGB">
        <feTurbulence type="fractalNoise" baseFrequency="0.25 0.35" numOctaves="2" seed="11" result="paperGrain" />
        <feComponentTransfer in="paperGrain" result="inkFlow">
          <feFuncR type="table" tableValues="0.48 0.52 0.56" />
          <feFuncG type="table" tableValues="0.48 0.52 0.56" />
          <feFuncB type="table" tableValues="0.48 0.52 0.56" />
        </feComponentTransfer>
        <feDisplacementMap in="SourceGraphic" in2="inkFlow" scale="0.65" xChannelSelector="R" yChannelSelector="G" result="waveredInk" />
        <feGaussianBlur in="waveredInk" stdDeviation="0.35" result="featheredInk" />
        <feComponentTransfer in="featheredInk" result="inked">
          <feFuncR type="gamma" amplitude="0.98" exponent="0.9" offset="0" />
          <feFuncG type="gamma" amplitude="0.98" exponent="0.9" offset="0" />
          <feFuncB type="gamma" amplitude="0.98" exponent="0.9" offset="0" />
          <feFuncA type="table" tableValues="0 0.16 0.42 0.78 1" />
        </feComponentTransfer>
        <feComposite in="inked" in2="inkFlow" operator="arithmetic" k1="0" k2="1" k3="0.08" k4="0" result="finalInk" />
      </filter>
    </defs>
  </svg>

  <div id="controls-container">
    <h1>Hallucination Controls</h1>
    <div id="hud-controls-panel" style="margin-bottom: 2rem; padding: 1.25rem; border-radius: 12px; background: rgba(15, 23, 42, 0.6); color: #e2e8f0; box-shadow: 0 10px 30px rgba(0,0,0,0.35);">
      <h2 style="margin-top: 0; margin-bottom: 1rem; color: #e63946; filter: url(#ballpoint-ink);">HUD Controls</h2>
      <div id="music-controller" class="row" style="margin-bottom: 12px; padding: 16px; border-radius: 12px; background: rgba(15, 23, 42, 0.65);">
        <h3 style="margin: 0 0 12px; font-size: 1.1rem; color: #e63946; filter: url(#ballpoint-ink);">üéµ Music Control</h3>
        <!-- Audio uploads below feed ONLY the music system (not video atoms or playlists). -->
        <input multiple type="file" id="music-file-input" accept=".mp3,.wav,.ogg,.m4a" style="display: block; margin-bottom: 10px; padding: 6px 10px; border-radius: 6px; background: rgba(51, 65, 85, 0.5); border: 1px solid rgba(148, 163, 184, 0.2); color: #e2e8f0; cursor: pointer; font-size: 0.9rem;" />
        <div style="margin-bottom: 10px;">
          <button id="music-play" type="button" class="frame-rect" disabled style="margin-right: 6px;">Play</button>
          <button id="music-pause" type="button" class="frame-rect" disabled style="margin-right: 6px;">Pause</button>
          <button id="music-stop" type="button" class="frame-rect" disabled>Stop</button>
        </div>
        <div class="music-info" style="font-size: 0.85em; opacity: 0.8; filter: url(#ballpoint-ink);">
          <div id="music-file-name">No file loaded</div>
          <div id="music-bpm">BPM: --</div>
          <div id="music-status">Status: Idle</div>
        </div>
      </div>
      <div class="row" id="google-auth-row" style="margin-bottom: 12px; display: flex; align-items: center; gap: 10px; opacity: 0.7;">
        <button id="google-sign-in" type="button" class="frame-rect" disabled title="Google auth is inactive on this controls page">Sign in with Google</button>
        <span id="google-auth-status" style="opacity: 0.7;">Google auth unavailable on this page</span>
      </div>
      <div class="row" id="video-playlist-row" style="margin-bottom: 12px; display: flex; align-items: center; gap: 8px; flex-wrap: wrap;">
        <strong style="margin-right: 6px; filter: url(#ballpoint-ink);">Playlist:</strong>
        <select id="video-playlists" disabled style="min-width: 220px;" title="Disabled: legacy background video system is inactive"></select>
        <button id="video-load" type="button" class="frame-rect" disabled title="Disabled: playlist controls are inactive">Load</button>
        <button id="video-prev" type="button" class="frame-rect" disabled title="Disabled: playlist controls are inactive">‚èÆÔ∏è</button>
        <button id="video-next" type="button" class="frame-rect" disabled title="Disabled: playlist controls are inactive">‚è≠Ô∏è</button>
        <button id="video-shuffle" type="button" class="frame-rect" disabled title="Disabled: playlist controls are inactive">üîÄ</button>
        <button id="video-refresh" type="button" class="frame-rect" disabled title="Disabled: playlist controls are inactive">‚Üª</button>
        <label style="margin-left: 8px; filter: url(#ballpoint-ink);">Volume</label>
        <input id="video-volume" type="range" min="0" max="100" step="1" value="50" disabled title="Disabled: playlist controls are inactive" />
        <span id="playlist-status" style="margin-left: 10px; font-size: 0.85em; opacity: 0.7;">Background playlist system disabled</span>
      </div>
      <div class="row" style="margin-bottom: 12px; display: flex; align-items: center; gap: 8px; flex-wrap: wrap;">
        <strong style="filter: url(#ballpoint-ink);">Tag:</strong>
        <button data-tag="Dreamcore" class="frame-rect">Dreamcore</button>
        <button data-tag="Ambient" class="frame-rect">Ambient</button>
        <button data-tag="Urban" class="frame-rect">Urban</button>
        <span id="current-tag" style="margin-left:12px; opacity: 0.6;">None</span>
      </div>
      <div class="row" id="fit-status-row" style="font-size: 0.85em; opacity: 0.75; display: flex; align-items: center; gap: 12px;">
        <span id="fit-status">Google Fit inactive on this page</span>
        <span style="margin-left: auto;">Session: <span id="session-time">0:00</span></span>
      </div>
      <div class="row" style="margin-top: 12px; display: flex; gap: 10px; flex-wrap: wrap;">
        <a href="hand-drawn-demo.html" target="_blank" class="frame-rect" style="text-decoration: none; padding: 10px 14px; display: inline-block;">Hand-Drawn Demo</a>
        <a href="index.html" class="frame-rect" style="text-decoration: none; padding: 10px 14px; display: inline-block;">Back to HUD</a>
      </div>
    </div>
    <div id="hallucination-controls-mount"></div>
  </div>

  <script type="module">
    import { recordTag } from './hallucinationEngine.js';
    import { startTimer } from './timer.js';

    // Music controller (audio-only; does not modify video atom playback or playlists)
    let audioContext = null;
    let analyserNode = null;
    let activeSource = null;
    let isPlaying = false;
    let startTime = 0;
    let pauseTime = 0;
    const localPlaylist = [];
    let currentTrackIndex = -1;

    const fileInput = document.getElementById('music-file-input');
    const playBtn = document.getElementById('music-play');
    const pauseBtn = document.getElementById('music-pause');
    const stopBtn = document.getElementById('music-stop');
    const fileNameEl = document.getElementById('music-file-name');
    const bpmEl = document.getElementById('music-bpm');
    const statusEl = document.getElementById('music-status');

    function initAudioContext() {
      if (!audioContext) {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        analyserNode = audioContext.createAnalyser();
        analyserNode.fftSize = 2048;
        analyserNode.connect(audioContext.destination);
      }
    }

    function stopActiveSource(resetPosition = true) {
      if (activeSource) {
        try {
          activeSource.onended = null;
          activeSource.stop();
        } catch (err) {
          console.warn('Error stopping source', err);
        }
        activeSource.disconnect();
        activeSource = null;
      }
      if (resetPosition) {
        pauseTime = 0;
        startTime = 0;
      }
      isPlaying = false;
    }

    function updateControlsAvailability() {
      const hasTrack = currentTrackIndex >= 0 && !!localPlaylist[currentTrackIndex];
      playBtn.disabled = !hasTrack;
      pauseBtn.disabled = !hasTrack;
      stopBtn.disabled = !hasTrack;
    }

    function updateTrackDisplay() {
      if (!fileNameEl) return;
      if (!localPlaylist.length || currentTrackIndex < 0) {
        fileNameEl.textContent = 'No file loaded';
        return;
      }
      const selected = localPlaylist[currentTrackIndex] || localPlaylist[0];
      if (!localPlaylist[currentTrackIndex]) {
        currentTrackIndex = 0;
      }
      fileNameEl.textContent = `Current: ${selected.displayName} (${localPlaylist.length} queued)`;
    }

    function playMusic() {
      const track = localPlaylist[currentTrackIndex];
      if (!track || !audioContext) return;
      if (audioContext.state === 'suspended') {
        audioContext.resume();
      }
      stopActiveSource(false);
      activeSource = audioContext.createBufferSource();
      activeSource.buffer = track.buffer;
      activeSource.connect(analyserNode);

      const offset = pauseTime;
      activeSource.start(0, offset);
      startTime = audioContext.currentTime - offset;
      isPlaying = true;
      statusEl.textContent = 'Status: Playing';

      activeSource.onended = () => {
        if (isPlaying) {
          stopActiveSource(true);
          statusEl.textContent = 'Status: Ended';
        }
      };
    }

    function pauseMusic() {
      if (!activeSource || !isPlaying || !audioContext) return;
      pauseTime = audioContext.currentTime - startTime;
      stopActiveSource(false);
      statusEl.textContent = 'Status: Paused';
    }

    function stopMusic() {
      stopActiveSource(true);
      statusEl.textContent = 'Status: Stopped';
    }

    if (fileInput) {
      fileInput.addEventListener('change', async (e) => {
        const files = Array.from(e.target.files || []);
        if (!files.length) return;

        initAudioContext();
        statusEl.textContent = `Status: Loading ${files.length} file(s)...`;

        let loadedCount = 0;
        for (const file of files) {
          try {
            const arrayBuffer = await file.arrayBuffer();
            const decodedBuffer = await audioContext.decodeAudioData(arrayBuffer);
            localPlaylist.push({
              file,
              buffer: decodedBuffer,
              displayName: file.name,
            });
            loadedCount += 1;
          } catch (err) {
            console.error('Error loading audio:', err);
          }
        }

        if (loadedCount > 0) {
          if (currentTrackIndex === -1) {
            currentTrackIndex = 0;
          }
          updateTrackDisplay();
          statusEl.textContent = `Status: Ready (${localPlaylist.length} queued)`;
          updateControlsAvailability();

          bpmEl.textContent = 'BPM: ~120';
        } else {
          fileNameEl.textContent = 'Error loading file(s)';
          statusEl.textContent = 'Status: Error';
        }
      });
    }

    playBtn?.addEventListener('click', playMusic);
    pauseBtn?.addEventListener('click', pauseMusic);
    stopBtn?.addEventListener('click', stopMusic);

    // Tag buttons
    const tagButtons = document.querySelectorAll('button[data-tag]');
    const tagDisplay = document.getElementById('current-tag');
    tagButtons.forEach((btn) => {
      btn.addEventListener('click', () => {
        const tag = btn.dataset.tag;
        if (!tag) return;
        if (tagDisplay) {
          tagDisplay.textContent = tag;
        }
        recordTag(tag, 'HUD Controls');
        localStorage.setItem('selectedTag', tag);
      });
    });
    const saved = localStorage.getItem('selectedTag');
    if (saved && tagDisplay) {
      tagDisplay.textContent = saved;
    }

    // Fit status timer (display only)
    startTimer(document.getElementById('session-time'));
  </script>

  <script type="module">
    import { 
      configureEffectPacks,
      setEffectInterval,
      setRareChance,
      setIntensityMultiplier,
      updateBPM,
      recordTag,
      getRecentTags,
      clearRecentTags,
      exportSessionLog,
      replaySession,
      enableMusicDrivenMode,
      onBeat,
      onOnset,
      onEnergyRise,
      onEnergyDrop
    } from './hallucinationEngine.js';
    import { createHandDrawnButton } from './hand-drawn-rect.js';

    const PACKS = ['default', 'fog', 'dreamcore'];
    const MOODS = ['ambient', 'rare', 'glide', 'dreamcore'];
    const STORAGE_KEY = 'rv.hallucination.settings';

    const defaultMoods = () => ({
      ambient: true,
      rare: true,
      glide: true,
      dreamcore: true,
    });

    function loadSettings() {
      const defaults = {
        selectedPacks: ['default'],
        packMoods: {
          default: defaultMoods(),
          fog: defaultMoods(),
          dreamcore: defaultMoods(),
        },
        effectInterval: 4000,
        rareChance: 0.02,
        intensityMultiplier: 1,
        bpm: 100,
        bpmOverride: false,
        stepRate: 0,
        replaySpeed: 1,
      };

      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return defaults;
        const parsed = JSON.parse(raw);
        return {
          ...defaults,
          ...parsed,
          packMoods: { ...defaults.packMoods, ...(parsed.packMoods || {}) },
        };
      } catch (error) {
        console.warn('Failed to load settings', error);
        return defaults;
      }
    }

    function persistSettings(settings) {
      try {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(settings));
      } catch (error) {
        console.warn('Failed to persist settings', error);
      }
    }

    function applySettingsToEngine(settings) {
      configureEffectPacks({
        selectedPacks: settings.selectedPacks,
        moodFilters: settings.packMoods,
      });
      setEffectInterval(settings.effectInterval);
      setRareChance(settings.rareChance);
      setIntensityMultiplier(settings.intensityMultiplier);
      if (settings.bpmOverride) {
        updateBPM(settings.bpm);
      }
    }

    let settings = loadSettings();
    applySettingsToEngine(settings);

    function updateSettings(partial) {
      settings = { ...settings, ...partial };
      persistSettings(settings);
      applySettingsToEngine(settings);
      render();
    }

    function createSlider(label, min, max, step, value, onChange, asPercent = false) {
      const group = document.createElement('div');
      group.className = 'slider-group';

      const labelDiv = document.createElement('div');
      labelDiv.className = 'slider-label';
      
      const labelText = document.createElement('span');
      labelText.textContent = label;
      
      const valueText = document.createElement('span');
      valueText.textContent = asPercent ? `${Math.round(value * 100)}%` : value.toFixed(2).replace(/\.00$/, '');

      labelDiv.append(labelText, valueText);

      const slider = document.createElement('input');
      slider.type = 'range';
      slider.min = String(min);
      slider.max = String(max);
      slider.step = String(step);
      slider.value = String(value);

      slider.addEventListener('input', () => {
        const newValue = Number(slider.value);
        valueText.textContent = asPercent ? `${Math.round(newValue * 100)}%` : newValue.toFixed(2).replace(/\.00$/, '');
        onChange(newValue);
      });

      group.append(labelDiv, slider);
      return group;
    }

    function refreshTags(container) {
      const tags = getRecentTags(8);
      container.textContent = tags.length ? `Recent: ${tags.join(', ')}` : 'No tags recorded yet';
    }

    function render() {
      const container = document.getElementById('hallucination-controls-mount');
      container.innerHTML = '';

      // Effect Packs Section
      const packsSection = document.createElement('section');
      packsSection.innerHTML = '<h3>Effect Packs</h3>';
      
      PACKS.forEach(packName => {
        const card = document.createElement('div');
        card.className = 'pack-card';

        const packLabel = document.createElement('label');
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.checked = settings.selectedPacks.includes(packName);
        
        checkbox.addEventListener('change', () => {
          const next = new Set(settings.selectedPacks);
          if (checkbox.checked) {
            next.add(packName);
          } else {
            next.delete(packName);
          }
          if (!next.size) next.add('default');
          updateSettings({ selectedPacks: Array.from(next) });
        });

        const title = document.createElement('strong');
        title.textContent = packName.charAt(0).toUpperCase() + packName.slice(1);
        packLabel.append(checkbox, title);
        card.append(packLabel);

        // Moods
        const details = document.createElement('details');
        details.open = checkbox.checked;
        const summary = document.createElement('summary');
        summary.textContent = 'Moods';
        details.append(summary);

        const moodGrid = document.createElement('div');
        moodGrid.className = 'mood-grid';
        
        const packMoods = settings.packMoods[packName] || defaultMoods();
        
        MOODS.forEach(mood => {
          const moodLabel = document.createElement('label');
          const moodCheckbox = document.createElement('input');
          moodCheckbox.type = 'checkbox';
          moodCheckbox.checked = packMoods[mood];
          
          moodCheckbox.addEventListener('change', () => {
            const updated = {
              ...settings.packMoods,
              [packName]: { ...packMoods, [mood]: moodCheckbox.checked },
            };
            updateSettings({ packMoods: updated });
          });
          
          moodLabel.append(moodCheckbox, document.createTextNode(mood.charAt(0).toUpperCase() + mood.slice(1)));
          moodGrid.appendChild(moodLabel);
        });

        details.append(moodGrid);
        card.append(details);
        packsSection.append(card);
      });

      container.append(packsSection);

      // Sliders Section
      const slidersSection = document.createElement('section');
      slidersSection.innerHTML = '<h3>Spawn & Intensity</h3>';
      slidersSection.append(
        createSlider('Spawn Interval (ms)', 800, 8000, 200, settings.effectInterval, 
          value => updateSettings({ effectInterval: value })),
        createSlider('Rare Chance', 0, 0.25, 0.005, settings.rareChance, 
          value => updateSettings({ rareChance: value }), true),
        createSlider('Intensity Multiplier', 0.5, 2, 0.1, settings.intensityMultiplier, 
          value => updateSettings({ intensityMultiplier: value }))
      );
      container.append(slidersSection);

      // BPM Section
      const bpmSection = document.createElement('section');
      bpmSection.innerHTML = '<h3>Rhythm</h3>';
      
      const bpmRow = document.createElement('div');
      bpmRow.style.display = 'flex';
      bpmRow.style.alignItems = 'center';
      bpmRow.style.gap = '12px';
      bpmRow.style.marginBottom = '12px';
      
      const bpmLabel = document.createElement('span');
      bpmLabel.textContent = 'BPM';
      
      const bpmInput = document.createElement('input');
      bpmInput.type = 'number';
      bpmInput.min = '60';
      bpmInput.max = '190';
      bpmInput.value = String(settings.bpm);
      bpmInput.style.padding = '0.5rem';
      bpmInput.style.borderRadius = '4px';
      bpmInput.style.border = '1px solid rgba(255,255,255,0.2)';
      bpmInput.style.backgroundColor = 'rgba(0,0,0,0.3)';
      bpmInput.style.color = 'inherit';
      bpmInput.style.width = '100px';
      
      bpmInput.addEventListener('input', () => {
        const bpm = Number(bpmInput.value) || 100;
        updateSettings({ bpm });
        if (settings.bpmOverride) {
          updateBPM(bpm);
        }
      });

      const overrideLabel = document.createElement('label');
      overrideLabel.style.display = 'flex';
      overrideLabel.style.alignItems = 'center';
      overrideLabel.style.gap = '6px';
      
      const overrideCheckbox = document.createElement('input');
      overrideCheckbox.type = 'checkbox';
      overrideCheckbox.checked = settings.bpmOverride;
      overrideCheckbox.addEventListener('change', () => {
        updateSettings({ bpmOverride: overrideCheckbox.checked });
      });
      
      overrideLabel.append(overrideCheckbox, document.createTextNode('Override auto BPM detection'));
      bpmRow.append(bpmLabel, bpmInput, overrideLabel);
      bpmSection.append(bpmRow);
      container.append(bpmSection);

      // Session Controls Section
      const sessionSection = document.createElement('section');
      sessionSection.innerHTML = '<h3>Session</h3>';
      
      const exportBtn = createHandDrawnButton('Export Session Log', {
        width: 180,
        height: 36,
        seed: 'Export Session Log'.charCodeAt(0),
      });
      exportBtn.style.marginBottom = '12px';
      exportBtn.addEventListener('click', () => {
        exportSessionLog();
      });
      
      const importLabel = document.createElement('label');
      importLabel.style.display = 'flex';
      importLabel.style.flexDirection = 'column';
      importLabel.style.gap = '6px';
      importLabel.style.marginBottom = '12px';
      importLabel.textContent = 'Replay log (.json)';
      
      const importInput = document.createElement('input');
      importInput.type = 'file';
      importInput.accept = '.json,application/json';
      importInput.addEventListener('change', async () => {
        const file = importInput.files?.[0];
        if (!file) return;
        try {
          const content = await file.text();
          const data = JSON.parse(content);
          replaySession(data, settings.replaySpeed || 1);
        } catch (error) {
          console.warn('Failed to replay log', error);
        }
      });
      importLabel.append(importInput);
      
      const replaySpeedLabel = document.createElement('label');
      replaySpeedLabel.style.display = 'flex';
      replaySpeedLabel.style.flexDirection = 'column';
      replaySpeedLabel.style.gap = '6px';
      replaySpeedLabel.style.marginBottom = '12px';
      replaySpeedLabel.textContent = 'Replay speed';
      
      const replaySpeed = document.createElement('input');
      replaySpeed.type = 'number';
      replaySpeed.step = '0.25';
      replaySpeed.min = '0.25';
      replaySpeed.value = String(settings.replaySpeed ?? 1);
      replaySpeed.style.padding = '0.5rem';
      replaySpeed.style.borderRadius = '4px';
      replaySpeed.style.border = '1px solid rgba(255,255,255,0.2)';
      replaySpeed.style.backgroundColor = 'rgba(0,0,0,0.3)';
      replaySpeed.style.color = 'inherit';
      replaySpeed.style.width = '100px';
      replaySpeed.addEventListener('input', () => {
        updateSettings({ replaySpeed: Number(replaySpeed.value) || 1 });
      });
      replaySpeedLabel.append(replaySpeed);
      
      const stepRateRow = document.createElement('div');
      stepRateRow.style.display = 'flex';
      stepRateRow.style.alignItems = 'center';
      stepRateRow.style.gap = '8px';
      stepRateRow.style.marginBottom = '12px';
      
      const stepRateLabel = document.createElement('span');
      stepRateLabel.textContent = 'Step rate (for preview)';
      
      const stepRateInput = document.createElement('input');
      stepRateInput.type = 'range';
      stepRateInput.min = '0';
      stepRateInput.max = '180';
      stepRateInput.step = '1';
      stepRateInput.value = String(settings.stepRate ?? 0);
      stepRateInput.style.flex = '1';
      
      const stepRateValue = document.createElement('span');
      stepRateValue.textContent = `${settings.stepRate ?? 0} spm`;
      stepRateValue.style.minWidth = '60px';
      
      stepRateInput.addEventListener('input', () => {
        const value = Number(stepRateInput.value) || 0;
        stepRateValue.textContent = `${value} spm`;
        updateSettings({ stepRate: value });
      });
      
      stepRateRow.append(stepRateLabel, stepRateInput, stepRateValue);
      
      sessionSection.append(exportBtn, importLabel, replaySpeedLabel, stepRateRow);
      container.append(sessionSection);

      // Tags Section
      const tagsSection = document.createElement('section');
      tagsSection.innerHTML = '<h3>Tags</h3>';
      
      const recentTags = document.createElement('div');
      recentTags.style.marginBottom = '12px';
      refreshTags(recentTags);
      
      const addRow = document.createElement('div');
      addRow.style.display = 'flex';
      addRow.style.gap = '8px';
      
      const tagInput = document.createElement('input');
      tagInput.type = 'text';
      tagInput.placeholder = 'Add tag';
      tagInput.style.flex = '1';
      tagInput.style.padding = '0.5rem';
      tagInput.style.borderRadius = '4px';
      tagInput.style.border = '1px solid rgba(255,255,255,0.2)';
      tagInput.style.backgroundColor = 'rgba(0,0,0,0.3)';
      tagInput.style.color = 'inherit';
      
      const addBtn = createHandDrawnButton('Add', {
        width: 80,
        height: 36,
        seed: 'Add'.charCodeAt(0),
      });
      addBtn.addEventListener('click', () => {
        if (!tagInput.value.trim()) return;
        recordTag(tagInput.value.trim());
        tagInput.value = '';
        refreshTags(recentTags);
      });
      
      const clearBtn = createHandDrawnButton('Clear', {
        width: 80,
        height: 36,
        seed: 'Clear'.charCodeAt(0),
      });
      clearBtn.addEventListener('click', () => {
        clearRecentTags();
        refreshTags(recentTags);
      });
      
      addRow.append(tagInput, addBtn, clearBtn);
      tagsSection.append(recentTags, addRow);
      container.append(tagsSection);

      // Music Controls Section
      const musicSection = document.createElement('section');
      musicSection.innerHTML = '<h3>Music-Driven Mode</h3>';
      
      const musicInfo = document.createElement('p');
      musicInfo.textContent = 'Upload audio to sync effects with real-time music analysis (BPM, beats, onsets).';
      musicInfo.style.margin = '0 0 1rem 0';
      musicInfo.style.fontSize = '0.9rem';
      musicInfo.style.opacity = '0.8';
      musicSection.append(musicInfo);

      const musicStatus = document.createElement('div');
      musicStatus.id = 'music-status';
      musicStatus.style.padding = '0.75rem';
      musicStatus.style.marginBottom = '1rem';
      musicStatus.style.borderRadius = '8px';
      musicStatus.style.backgroundColor = 'rgba(0,0,0,0.3)';
      musicStatus.style.fontSize = '0.85rem';
      musicStatus.textContent = '‚ö™ No music loaded';
      musicSection.append(musicStatus);

      const uploadBtn = createHandDrawnButton('Upload Music File', {
        width: 180,
        height: 40,
        seed: 'Upload'.charCodeAt(0),
      });
      uploadBtn.style.marginRight = '0.5rem';
      
      const playBtn = createHandDrawnButton('Play', {
        width: 100,
        height: 40,
        seed: 'Play'.charCodeAt(0),
      });
      playBtn.disabled = true;
      playBtn.style.opacity = '0.5';
      playBtn.style.marginRight = '0.5rem';

      const stopBtn = createHandDrawnButton('Stop', {
        width: 100,
        height: 40,
        seed: 'Stop'.charCodeAt(0),
      });
      stopBtn.disabled = true;
      stopBtn.style.opacity = '0.5';

      const btnGroup = document.createElement('div');
      btnGroup.style.display = 'flex';
      btnGroup.style.gap = '0.5rem';
      btnGroup.style.flexWrap = 'wrap';
      btnGroup.append(uploadBtn, playBtn, stopBtn);
      musicSection.append(btnGroup);

      // Music state
      let audioContext = null;
      let audioBuffer = null;
      let sourceNode = null;
      let isPlaying = false;

      uploadBtn.addEventListener('click', async () => {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = 'audio/mpeg,audio/wav,audio/ogg,audio/x-m4a,audio/mp4,.mp3,.wav,.ogg,.m4a';
        
        input.onchange = async () => {
          const file = input.files?.[0];
          if (!file) return;

          try {
            musicStatus.textContent = '‚è≥ Loading...';
            
            if (!audioContext) {
              audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }

            const arrayBuffer = await file.arrayBuffer();
            audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
            
            musicStatus.textContent = `‚úÖ ${file.name} loaded (${Math.round(audioBuffer.duration)}s)`;
            musicStatus.style.backgroundColor = 'rgba(5, 150, 105, 0.3)';
            
            playBtn.disabled = false;
            playBtn.style.opacity = '1';
            
            // Setup music bridge if renderer.js has exposed it
            if (window.setupMusicBridge && window.setMusicActive) {
              // The full music system from rv-app can be integrated here
              console.log('Music system ready - full DSP analysis available');
            }
          } catch (error) {
            musicStatus.textContent = `‚ùå Error: ${error.message}`;
            musicStatus.style.backgroundColor = 'rgba(220, 38, 38, 0.3)';
          }
        };
        
        input.click();
      });

      playBtn.addEventListener('click', () => {
        if (!audioContext || !audioBuffer) return;

        if (isPlaying) {
          // Pause
          if (sourceNode) {
            sourceNode.stop();
            sourceNode = null;
          }
          isPlaying = false;
          playBtn.textContent = 'Play';
          musicStatus.textContent = '‚è∏ Paused';
          musicStatus.style.backgroundColor = 'rgba(0,0,0,0.3)';
          enableMusicDrivenMode(false);
          
          if (window.setMusicActive) {
            window.setMusicActive(false);
          }
        } else {
          // Play
          sourceNode = audioContext.createBufferSource();
          sourceNode.buffer = audioBuffer;
          sourceNode.connect(audioContext.destination);
          sourceNode.start(0);
          
          sourceNode.onended = () => {
            isPlaying = false;
            playBtn.textContent = 'Play';
            musicStatus.textContent = '‚èπ Track ended';
            musicStatus.style.backgroundColor = 'rgba(0,0,0,0.3)';
            enableMusicDrivenMode(false);
            
            if (window.setMusicActive) {
              window.setMusicActive(false);
            }
            
            stopBtn.disabled = true;
            stopBtn.style.opacity = '0.5';
          };
          
          isPlaying = true;
          playBtn.textContent = 'Pause';
          musicStatus.textContent = '‚ñ∂Ô∏è Playing - Music-driven mode active';
          musicStatus.style.backgroundColor = 'rgba(5, 150, 105, 0.3)';
          enableMusicDrivenMode(true);
          
          if (window.setMusicActive) {
            window.setMusicActive(true);
          }
          
          stopBtn.disabled = false;
          stopBtn.style.opacity = '1';
        }
      });

      stopBtn.addEventListener('click', () => {
        if (sourceNode) {
          sourceNode.stop();
          sourceNode = null;
        }
        isPlaying = false;
        playBtn.textContent = 'Play';
        musicStatus.textContent = '‚èπ Stopped';
        musicStatus.style.backgroundColor = 'rgba(0,0,0,0.3)';
        enableMusicDrivenMode(false);
        
        if (window.setMusicActive) {
          window.setMusicActive(false);
        }
        
        stopBtn.disabled = true;
        stopBtn.style.opacity = '0.5';
      });

      container.append(musicSection);

      // Randomize Button
      const randomizeBtn = createHandDrawnButton('Randomize Everything', {
        width: 220,
        height: 40,
        seed: 'Randomize Everything'.charCodeAt(0),
      });
      randomizeBtn.style.marginTop = '1rem';
      randomizeBtn.style.display = 'block';
      randomizeBtn.addEventListener('click', () => {
        const randomPackSelection = PACKS.filter(() => Math.random() > 0.4);
        const selectedPacks = randomPackSelection.length ? randomPackSelection : ['default'];
        
        const packMoods = { ...settings.packMoods };
        selectedPacks.forEach(pack => {
          const moods = { ...packMoods[pack] };
          MOODS.forEach(mood => {
            moods[mood] = Math.random() > 0.2;
          });
          packMoods[pack] = moods;
        });
        
        updateSettings({
          selectedPacks,
          packMoods,
          effectInterval: Math.round(800 + Math.random() * 6000),
          rareChance: Math.random() * 0.25,
          intensityMultiplier: Number((0.5 + Math.random() * 1.5).toFixed(2)),
          bpm: 80 + Math.round(Math.random() * 80),
          bpmOverride: Math.random() > 0.5,
          stepRate: Math.round(Math.random() * 160),
          replaySpeed: Number((0.5 + Math.random() * 1.5).toFixed(2)),
        });
      });
      
      container.append(randomizeBtn);
    }

    render();
  </script>
</body>
</html>
